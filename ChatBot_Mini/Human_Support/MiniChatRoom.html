<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Chat Room - P2P</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        width: 90%;
        max-width: 800px;
        height: 600px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        text-align: center;
      }

      .header h1 {
        font-size: 24px;
        margin-bottom: 5px;
      }

      .header p {
        opacity: 0.9;
        font-size: 14px;
      }

      .login-screen {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
      }

      .login-form {
        background: #f8f9fa;
        padding: 30px;
        border-radius: 10px;
        width: 100%;
        max-width: 400px;
        text-align: center;
      }

      .login-form h2 {
        color: #333;
        margin-bottom: 20px;
      }

      .input-group {
        margin-bottom: 20px;
      }

      .input-group label {
        display: block;
        margin-bottom: 5px;
        color: #555;
        font-weight: 500;
      }

      .input-group input,
      .input-group select {
        width: 100%;
        padding: 12px;
        border: 2px solid #e1e5e9;
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.3s;
      }

      .input-group input:focus,
      .input-group select:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .chat-screen {
        flex: 1;
        display: none;
        flex-direction: column;
        overflow: scroll;
      }

      .chat-info {
        background: #f8f9fa;
        padding: 15px 20px;
        border-bottom: 1px solid #e1e5e9;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .user-info {
        font-weight: 500;
        color: #333;
      }

      .room-info {
        font-size: 14px;
        color: #666;
      }

      .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: #fafafa;
      }

      .message {
        margin-bottom: 15px;
        padding: 10px 15px;
        border-radius: 10px;
        max-width: 70%;
        word-wrap: break-word;
      }

      .message.own {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        margin-left: auto;
        text-align: right;
      }

      .message.other {
        background: white;
        border: 1px solid #e1e5e9;
        margin-right: auto;
      }

      .message-header {
        font-size: 12px;
        opacity: 0.8;
        margin-bottom: 5px;
      }

      .message.own .message-header {
        color: rgba(255, 255, 255, 0.8);
      }

      .message.other .message-header {
        color: #666;
      }

      .message-input {
        display: flex;
        padding: 20px;
        background: white;
        border-top: 1px solid #e1e5e9;
      }

      .message-input input {
        flex: 1;
        padding: 12px;
        border: 2px solid #e1e5e9;
        border-radius: 25px;
        font-size: 16px;
        margin-right: 10px;
      }

      .message-input input:focus {
        outline: none;
        border-color: #667eea;
      }

      .send-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 16px;
      }

      .status {
        padding: 10px 20px;
        background: #e3f2fd;
        border-left: 4px solid #2196f3;
        margin: 10px 20px;
        border-radius: 4px;
        font-size: 14px;
      }

      .status.error {
        background: #ffebee;
        border-left-color: #f44336;
        color: #c62828;
      }

      .status.success {
        background: #e8f5e8;
        border-left-color: #4caf50;
        color: #2e7d32;
      }

      .peers-list {
        background: #f0f0f0;
        padding: 10px 20px;
        border-bottom: 1px solid #e1e5e9;
        font-size: 14px;
      }

      .peer-tag {
        display: inline-block;
        background: #667eea;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        margin-right: 8px;
        font-size: 12px;
      }

      @media (max-width: 600px) {
        .container {
          width: 95%;
          height: 90vh;
        }

        .message {
          max-width: 85%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üöÄ Mini Chat Room</h1>
        <p>K·∫øt n·ªëi P2P tr·ª±c ti·∫øp - Kh√¥ng qua server</p>
      </div>

      <!-- Login Screen -->
      <div class="login-screen" id="loginScreen">
        <div class="login-form">
          <h2>Tham gia Chat Room</h2>
          <div class="input-group">
            <label for="nickname">Nickname c·ªßa b·∫°n:</label>
            <input
              type="text"
              id="nickname"
              placeholder="Nh·∫≠p t√™n hi·ªÉn th·ªã..."
              maxlength="20"
            />
          </div>
          <div class="input-group">
            <label for="roomId">Room ID:</label>
            <select id="roomId">
              <option value="public-room-1">üåç Public Room 1</option>
              <option value="public-room-2">üéÆ Gaming Room</option>
              <option value="public-room-3">üíº Work Chat</option>
              <option value="custom">üîß Custom Room</option>
            </select>
          </div>
          <div class="input-group" id="customRoomGroup" style="display: none">
            <label for="customRoom">Custom Room ID:</label>
            <input
              type="text"
              id="customRoom"
              placeholder="Nh·∫≠p room ID t√πy ch·ªânh..."
            />
          </div>
          <button class="btn" id="joinBtn" onclick="joinRoom()">
            Tham gia Chat
          </button>
        </div>
      </div>

      <!-- Chat Screen -->
      <div class="chat-screen" id="chatScreen">
        <div class="chat-info">
          <div class="user-info" id="userInfo"></div>
          <div class="room-info" id="roomInfo"></div>
        </div>
        <div class="peers-list" id="peersList" style="display: none"></div>
        <div class="status" id="connectionStatus">ƒêang k·∫øt n·ªëi...</div>
        <div class="messages-container" id="messagesContainer"></div>
        <div class="message-input">
          <input
            type="text"
            id="messageInput"
            placeholder="Nh·∫≠p tin nh·∫Øn..."
            maxlength="500"
          />
          <button class="send-btn" onclick="sendMessage()">G·ª≠i</button>
          <button
            class="btn"
            onclick="retryConnections()"
            style="margin-left: 10px; padding: 8px 16px; font-size: 14px"
          >
            üîÑ Retry
          </button>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let currentUser = {
        nickname: "",
        peerID: "",
        roomID: "",
      };

      let chatSocket = null;
      let connectedUsers = new Set(); // Set of connected user IDs in room
      let messageQueue = []; // Queue messages until connected
      let reconnectAttempts = 0;
      let maxReconnectAttempts = 5;
      let reconnectDelay = 1000; // Start with 1 second
      let pingInterval = null;
      let isConnecting = false;
      let isManualDisconnect = false;

      const CHAT_SERVER =
        "wss://vanced-chatbot.caocv-work.workers.dev/p2p/room/";

      // Debug configuration
      const DEBUG_P2P = true;

      function debugP2P(message, data = null) {
        if (!DEBUG_P2P) return;
        const timestamp = new Date().toISOString();
        if (data) {
          console.log(`[P2P-DEBUG ${timestamp}] ${message}`, data);
        } else {
          console.log(`[P2P-DEBUG ${timestamp}] ${message}`);
        }
      }

      // UI Event Handlers
      document.getElementById("roomId").addEventListener("change", function () {
        const customGroup = document.getElementById("customRoomGroup");
        if (this.value === "custom") {
          customGroup.style.display = "block";
        } else {
          customGroup.style.display = "none";
        }
      });

      document
        .getElementById("messageInput")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            sendMessage();
          }
        });

      document
        .getElementById("nickname")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            joinRoom();
          }
        });

      // Generate unique peer ID
      function generatePeerID() {
        return (
          "user_" +
          Math.random().toString(36).substr(2, 9) +
          "_" +
          Date.now().toString(36)
        );
      }

      // Join room function
      async function joinRoom() {
        const nickname = document.getElementById("nickname").value.trim();
        const roomSelect = document.getElementById("roomId").value;

        let roomID;
        if (roomSelect === "custom") {
          roomID = document.getElementById("customRoom").value.trim();
          if (!roomID) {
            alert("Vui l√≤ng nh·∫≠p Room ID t√πy ch·ªânh!");
            return;
          }
        } else {
          roomID = roomSelect;
        }

        if (!nickname) {
          alert("Vui l√≤ng nh·∫≠p nickname!");
          return;
        }

        // Set user info
        currentUser.nickname = nickname;
        currentUser.peerID = generatePeerID();
        currentUser.roomID = roomID;

        // Switch to chat screen
        document.getElementById("loginScreen").style.display = "none";
        document.getElementById("chatScreen").style.display = "flex";

        // Update UI
        document.getElementById("userInfo").textContent = `üë§ ${nickname}`;
        document.getElementById("roomInfo").textContent = `üè† ${roomID}`;

        // Connect to chat server
        await connectToChatServer();
      }

      // Connect to chat server with auto-reconnect
      async function connectToChatServer() {
        if (isConnecting) {
          console.log("Already connecting, skipping...");
          return;
        }

        isConnecting = true;

        try {
          updateStatus("ƒêang k·∫øt n·ªëi ƒë·∫øn chat server...", "info");

          const wsUrl = `${CHAT_SERVER}${currentUser.roomID}?peerID=${
            currentUser.peerID
          }&roomID=${currentUser.roomID}&nickname=${encodeURIComponent(
            currentUser.nickname
          )}`;
          chatSocket = new WebSocket(wsUrl);

          chatSocket.onopen = () => {
            updateStatus("‚úÖ ƒê√£ k·∫øt n·ªëi - S·∫µn s√†ng chat!", "success");
            console.log("Connected to chat server");

            // Reset reconnect attempts on successful connection
            reconnectAttempts = 0;
            reconnectDelay = 1000;
            isConnecting = false;

            // Send queued messages
            while (messageQueue.length > 0) {
              const queuedMessage = messageQueue.shift();
              sendMessageViaWebSocket(queuedMessage);
            }

            // Start ping interval to keep connection alive
            startPingInterval();
          };

          chatSocket.onmessage = async (event) => {
            const message = JSON.parse(event.data);
            await handleChatMessage(message);
          };

          chatSocket.onclose = (event) => {
            console.log("WebSocket closed:", event.code, event.reason);
            isConnecting = false;
            stopPingInterval();

            if (!isManualDisconnect) {
              updateStatus("‚ùå M·∫•t k·∫øt n·ªëi ƒë·∫øn server", "error");
              attemptReconnect();
            }
          };

          chatSocket.onerror = (error) => {
            console.error("Chat socket error:", error);
            isConnecting = false;
            updateStatus("‚ùå L·ªói k·∫øt n·ªëi WebSocket", "error");
          };
        } catch (error) {
          isConnecting = false;
          updateStatus("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi: " + error.message, "error");
          console.error("Connection error:", error);
          attemptReconnect();
        }
      }

      // Start ping interval to keep connection alive
      function startPingInterval() {
        stopPingInterval(); // Clear any existing interval

        pingInterval = setInterval(() => {
          if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({ type: "ping" }));
            console.log("Sent ping to server");
          } else {
            stopPingInterval();
          }
        }, 30000); // Ping every 30 seconds
      }

      // Stop ping interval
      function stopPingInterval() {
        if (pingInterval) {
          clearInterval(pingInterval);
          pingInterval = null;
        }
      }

      // Attempt to reconnect with exponential backoff
      function attemptReconnect() {
        if (isManualDisconnect || reconnectAttempts >= maxReconnectAttempts) {
          if (reconnectAttempts >= maxReconnectAttempts) {
            updateStatus(
              "‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi l·∫°i. Vui l√≤ng refresh trang.",
              "error"
            );
          }
          return;
        }

        reconnectAttempts++;
        const delay = Math.min(
          reconnectDelay * Math.pow(2, reconnectAttempts - 1),
          30000
        );

        updateStatus(
          `üîÑ ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i... (${reconnectAttempts}/${maxReconnectAttempts})`,
          "info"
        );

        setTimeout(() => {
          if (!isManualDisconnect) {
            connectToChatServer();
          }
        }, delay);
      }

      // Handle chat messages
      async function handleChatMessage(message) {
        console.log("Received chat message:", message);

        switch (message.type) {
          case "connected":
            updateStatus(`‚úÖ ƒê√£ tham gia room: ${message.roomID}`, "success");
            // Request user list
            chatSocket.send(JSON.stringify({ type: "get-users" }));
            break;

          case "user-joined":
            if (message.peerID !== currentUser.peerID) {
              const nickname = message.nickname || message.peerID;
              updateStatus(`üëã ${nickname} ƒë√£ tham gia`, "info");
              connectedUsers.add(message.peerID);
              updateUsersDisplay();
            }
            break;

          case "user-left":
            if (message.peerID !== currentUser.peerID) {
              const nickname = message.nickname || message.peerID;
              updateStatus(`üëã ${nickname} ƒë√£ r·ªùi kh·ªèi room`, "info");
              connectedUsers.delete(message.peerID);
              updateUsersDisplay();
            }
            break;

          case "user-list":
            updateUsersList(message.users);
            break;

          case "chat-message":
            // Display received message
            if (message.fromPeerID !== currentUser.peerID) {
              displayMessage(message, false);
            }
            break;

          case "pong":
            console.log("Received pong from server - connection alive");
            break;

          default:
            console.log("Unknown message type:", message.type);
        }
      }

      // Create peer connection
      async function createPeerConnection(peerID, shouldCreateOffer) {
        if (peers.has(peerID)) {
          console.log("Peer connection already exists for:", peerID);
          return;
        }

        console.log(
          "Creating peer connection for:",
          peerID,
          "shouldCreateOffer:",
          shouldCreateOffer
        );

        const peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" },
            { urls: "stun:stun3.l.google.com:19302" },
            { urls: "stun:stun4.l.google.com:19302" },
            // Free TURN servers for NAT traversal
            {
              urls: "turn:openrelay.metered.ca:80",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
            {
              urls: "turn:openrelay.metered.ca:443",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
            {
              urls: "turn:openrelay.metered.ca:443?transport=tcp",
              username: "openrelayproject",
              credential: "openrelayproject",
            },
          ],
          iceCandidatePoolSize: 10,
        });

        debugP2P(`Creating peer connection for ${peerID}`, {
          shouldCreateOffer,
          iceServers: peerConnection.getConfiguration().iceServers.length,
        });

        // Create data channel for messages
        let dataChannel;
        if (shouldCreateOffer) {
          dataChannel = peerConnection.createDataChannel("messages", {
            ordered: true,
          });
          setupDataChannel(dataChannel, peerID);
        }

        // Handle incoming data channel
        peerConnection.ondatachannel = (event) => {
          const channel = event.channel;
          setupDataChannel(channel, peerID);
        };

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          debugP2P(`ICE candidate for ${peerID}`, {
            hasCandidate: !!event.candidate,
            candidate: event.candidate?.candidate,
            type: event.candidate?.type,
            protocol: event.candidate?.protocol,
          });

          if (event.candidate) {
            signalingSocket.send(
              JSON.stringify({
                type: "ice-candidate",
                toPeerID: peerID,
                data: event.candidate,
              })
            );
          } else {
            debugP2P(`ICE gathering complete for ${peerID}`);
          }
        };

        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          debugP2P(`Connection state change for ${peerID}`, {
            connectionState: peerConnection.connectionState,
            iceConnectionState: peerConnection.iceConnectionState,
            iceGatheringState: peerConnection.iceGatheringState,
          });

          console.log(
            `Connection state with ${peerID}:`,
            peerConnection.connectionState
          );

          if (peerConnection.connectionState === "connected") {
            connectedPeers.add(peerID);
            updateStatus(`‚úÖ ƒê√£ k·∫øt n·ªëi P2P v·ªõi ${peerID}`, "success");
            updatePeersDisplay();
          } else if (
            peerConnection.connectionState === "disconnected" ||
            peerConnection.connectionState === "failed"
          ) {
            debugP2P(`Connection failed/disconnected for ${peerID}`, {
              connectionState: peerConnection.connectionState,
              iceConnectionState: peerConnection.iceConnectionState,
            });
            connectedPeers.delete(peerID);
            removePeer(peerID);
          }
        };

        // Additional ICE connection state monitoring
        peerConnection.oniceconnectionstatechange = () => {
          debugP2P(`ICE connection state change for ${peerID}`, {
            iceConnectionState: peerConnection.iceConnectionState,
            connectionState: peerConnection.connectionState,
          });

          if (peerConnection.iceConnectionState === "failed") {
            debugP2P(
              `ICE connection failed for ${peerID} - attempting restart`
            );
            // Attempt ICE restart
            peerConnection.restartIce();
          }
        };

        // ICE gathering state monitoring
        peerConnection.onicegatheringstatechange = () => {
          debugP2P(`ICE gathering state change for ${peerID}`, {
            iceGatheringState: peerConnection.iceGatheringState,
          });
        };

        peers.set(peerID, peerConnection);

        // Set connection timeout
        const connectionTimeout = setTimeout(() => {
          if (peerConnection.connectionState !== "connected") {
            debugP2P(`Connection timeout for ${peerID}`, {
              connectionState: peerConnection.connectionState,
              iceConnectionState: peerConnection.iceConnectionState,
            });

            updateStatus(`‚è∞ Timeout k·∫øt n·ªëi v·ªõi ${peerID}`, "error");
            removePeer(peerID);
          }
        }, 30000); // 30 second timeout

        // Clear timeout when connected
        const originalOnConnectionStateChange =
          peerConnection.onconnectionstatechange;
        peerConnection.onconnectionstatechange = () => {
          if (peerConnection.connectionState === "connected") {
            clearTimeout(connectionTimeout);
          }
          if (originalOnConnectionStateChange) {
            originalOnConnectionStateChange();
          }
        };

        // Create offer if needed
        if (shouldCreateOffer) {
          try {
            const offer = await peerConnection.createOffer({
              offerToReceiveAudio: false,
              offerToReceiveVideo: false,
            });
            await peerConnection.setLocalDescription(offer);

            debugP2P(`Created offer for ${peerID}`, {
              offerType: offer.type,
            });

            signalingSocket.send(
              JSON.stringify({
                type: "offer",
                toPeerID: peerID,
                data: offer,
              })
            );
          } catch (error) {
            debugP2P(`Error creating offer for ${peerID}`, {
              error: error.message,
            });
            clearTimeout(connectionTimeout);
            removePeer(peerID);
          }
        }
      }

      // Setup data channel
      function setupDataChannel(dataChannel, peerID) {
        debugP2P(`Setting up data channel for ${peerID}`, {
          readyState: dataChannel.readyState,
          label: dataChannel.label,
        });

        dataChannel.onopen = () => {
          debugP2P(`Data channel opened with ${peerID}`, {
            readyState: dataChannel.readyState,
            bufferedAmount: dataChannel.bufferedAmount,
          });
          console.log(`Data channel opened with ${peerID}`);
          connectedPeers.add(peerID);
          updatePeersDisplay();

          // Send queued messages
          debugP2P(
            `Sending ${messageQueue.length} queued messages to ${peerID}`
          );
          while (messageQueue.length > 0) {
            const queuedMessage = messageQueue.shift();
            broadcastMessage(queuedMessage);
          }
        };

        dataChannel.onmessage = (event) => {
          debugP2P(`Received message from ${peerID}`, {
            dataLength: event.data.length,
          });
          const message = JSON.parse(event.data);
          displayMessage(message, false);
        };

        dataChannel.onclose = () => {
          debugP2P(`Data channel closed with ${peerID}`);
          console.log(`Data channel closed with ${peerID}`);
          connectedPeers.delete(peerID);
          updatePeersDisplay();
        };

        dataChannel.onerror = (error) => {
          debugP2P(`Data channel error with ${peerID}`, {
            error: error.message || error,
            readyState: dataChannel.readyState,
          });
          console.error(`Data channel error with ${peerID}:`, error);
        };

        // Store data channel globally for easier access
        window.dataChannels.set(peerID, dataChannel);
      }

      // Handle WebRTC offer
      async function handleOffer(message) {
        const peerID = message.fromPeerID;

        debugP2P(`Received offer from ${peerID}`, {
          offerType: message.data.type,
          hasSdp: !!message.data.sdp,
        });

        if (!peers.has(peerID)) {
          await createPeerConnection(peerID, false);
        }

        const peerConnection = peers.get(peerID);

        try {
          await peerConnection.setRemoteDescription(message.data);
          debugP2P(`Set remote description for ${peerID}`);

          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          debugP2P(`Created and set answer for ${peerID}`, {
            answerType: answer.type,
          });

          signalingSocket.send(
            JSON.stringify({
              type: "answer",
              toPeerID: peerID,
              data: answer,
            })
          );
        } catch (error) {
          debugP2P(`Error handling offer from ${peerID}`, {
            error: error.message,
          });
          console.error(`Error handling offer from ${peerID}:`, error);
        }
      }

      // Handle WebRTC answer
      async function handleAnswer(message) {
        const peerID = message.fromPeerID;
        const peerConnection = peers.get(peerID);

        debugP2P(`Received answer from ${peerID}`, {
          answerType: message.data.type,
          hasSdp: !!message.data.sdp,
          hasPeerConnection: !!peerConnection,
        });

        if (peerConnection) {
          try {
            await peerConnection.setRemoteDescription(message.data);
            debugP2P(`Set remote description (answer) for ${peerID}`);
          } catch (error) {
            debugP2P(`Error setting remote description for ${peerID}`, {
              error: error.message,
            });
            console.error(
              `Error setting remote description for ${peerID}:`,
              error
            );
          }
        } else {
          debugP2P(
            `No peer connection found for ${peerID} when handling answer`
          );
        }
      }

      // Handle ICE candidate
      async function handleIceCandidate(message) {
        const peerID = message.fromPeerID;
        const peerConnection = peers.get(peerID);

        debugP2P(`Received ICE candidate from ${peerID}`, {
          candidate: message.data.candidate,
          type: message.data.type,
          protocol: message.data.protocol,
          hasPeerConnection: !!peerConnection,
        });

        if (peerConnection) {
          try {
            await peerConnection.addIceCandidate(message.data);
            debugP2P(`Added ICE candidate for ${peerID}`);
          } catch (error) {
            debugP2P(`Error adding ICE candidate for ${peerID}`, {
              error: error.message,
              candidate: message.data.candidate,
            });
            console.error(`Error adding ICE candidate for ${peerID}:`, error);
          }
        } else {
          debugP2P(
            `No peer connection found for ${peerID} when handling ICE candidate`
          );
        }
      }

      // Remove peer
      function removePeer(peerID) {
        if (peers.has(peerID)) {
          peers.get(peerID).close();
          peers.delete(peerID);
        }
        connectedPeers.delete(peerID);
        updatePeersDisplay();
      }

      // Send message
      function sendMessage() {
        const input = document.getElementById("messageInput");
        const messageText = input.value.trim();

        if (!messageText) return;

        const message = {
          from: currentUser.nickname,
          fromPeerID: currentUser.peerID,
          text: messageText,
          timestamp: new Date().toISOString(),
        };

        debugP2P(`Sending message`, {
          messageLength: messageText.length,
          connectedPeersCount: connectedPeers.size,
          queueLength: messageQueue.length,
        });

        // Display own message
        displayMessage(message, true);

        // Send to connected peers or queue
        if (connectedPeers.size > 0) {
          broadcastMessage(message);

          // Check if message was actually sent
          if (connectedPeers.size === 0) {
            // All connections failed during broadcast
            messageQueue.push(message);
            updateStatus(
              "üì§ K·∫øt n·ªëi P2P b·ªã l·ªói - Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c x·∫øp h√†ng",
              "error"
            );
          }
        } else {
          messageQueue.push(message);
          updateStatus("üì§ Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c x·∫øp h√†ng ch·ªù k·∫øt n·ªëi", "info");
          debugP2P(`Message queued`, {
            queueLength: messageQueue.length,
            totalPeers: peers.size,
          });
        }

        input.value = "";
      }

      // Broadcast message to all connected peers
      function broadcastMessage(message) {
        const messageStr = JSON.stringify(message);
        let sentCount = 0;
        let failedCount = 0;

        debugP2P(`Broadcasting message`, {
          messageLength: messageStr.length,
          connectedPeersCount: connectedPeers.size,
          totalPeersCount: peers.size,
        });

        connectedPeers.forEach((peerID) => {
          if (window.dataChannels && window.dataChannels.has(peerID)) {
            const channel = window.dataChannels.get(peerID);

            debugP2P(`Attempting to send to ${peerID}`, {
              readyState: channel.readyState,
              bufferedAmount: channel.bufferedAmount,
            });

            if (channel.readyState === "open") {
              try {
                channel.send(messageStr);
                sentCount++;
                debugP2P(`Message sent to ${peerID}`);
              } catch (error) {
                debugP2P(`Failed to send message to ${peerID}`, {
                  error: error.message,
                  readyState: channel.readyState,
                });
                failedCount++;
                // Remove from connected peers if send fails
                connectedPeers.delete(peerID);
              }
            } else {
              debugP2P(`Data channel not open for ${peerID}`, {
                readyState: channel.readyState,
              });
              failedCount++;
              // Remove from connected peers if channel not open
              connectedPeers.delete(peerID);
            }
          } else {
            debugP2P(`No data channel found for ${peerID}`);
            failedCount++;
            connectedPeers.delete(peerID);
          }
        });

        debugP2P(`Broadcast complete`, {
          sentCount,
          failedCount,
          connectedPeersAfter: connectedPeers.size,
        });

        console.log(
          `Message sent to ${sentCount} peers, ${failedCount} failed`
        );

        // Update UI to reflect actual connection status
        updatePeersDisplay();
      }

      // Display message in UI
      function displayMessage(message, isOwn) {
        const container = document.getElementById("messagesContainer");
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${isOwn ? "own" : "other"}`;

        const time = new Date(message.timestamp).toLocaleTimeString("vi-VN", {
          hour: "2-digit",
          minute: "2-digit",
        });

        messageDiv.innerHTML = `
                <div class="message-header">${
                  isOwn ? "B·∫°n" : message.from
                } ‚Ä¢ ${time}</div>
                <div>${escapeHtml(message.text)}</div>
            `;

        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }

      // Update status
      function updateStatus(message, type = "info") {
        const statusDiv = document.getElementById("connectionStatus");
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
      }

      // Update peers list
      function updatePeersList(peers) {
        const peersDiv = document.getElementById("peersList");

        if (peers.length <= 1) {
          peersDiv.style.display = "none";
          return;
        }

        peersDiv.style.display = "block";
        const otherPeers = peers.filter((p) => p.peerID !== currentUser.peerID);

        peersDiv.innerHTML = `
                <strong>üë• Ng∆∞·ªùi d√πng online (${otherPeers.length}):</strong> 
                ${otherPeers
                  .map((p) => `<span class="peer-tag">${p.peerID}</span>`)
                  .join("")}
            `;
      }

      // Update peers display
      function updatePeersDisplay() {
        const peersDiv = document.getElementById("peersList");
        const connectedCount = connectedPeers.size;

        if (connectedCount === 0) {
          peersDiv.style.display = "none";
          return;
        }

        peersDiv.style.display = "block";
        peersDiv.innerHTML = `
                <strong>üîó K·∫øt n·ªëi P2P (${connectedCount}):</strong> 
                ${Array.from(connectedPeers)
                  .map((id) => `<span class="peer-tag">${id}</span>`)
                  .join("")}
            `;
      }

      // Escape HTML
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Store data channels globally for easier access
      window.dataChannels = new Map();

      // Connection health check
      function checkConnectionHealth() {
        debugP2P(`Connection health check`, {
          totalPeers: peers.size,
          connectedPeers: connectedPeers.size,
          dataChannels: window.dataChannels.size,
          signalingConnected: signalingSocket?.readyState === WebSocket.OPEN,
        });

        // Check each peer connection
        peers.forEach((peerConnection, peerID) => {
          const isConnected = connectedPeers.has(peerID);
          const hasDataChannel = window.dataChannels.has(peerID);
          const dataChannel = window.dataChannels.get(peerID);

          debugP2P(`Peer ${peerID} status`, {
            connectionState: peerConnection.connectionState,
            iceConnectionState: peerConnection.iceConnectionState,
            iceGatheringState: peerConnection.iceGatheringState,
            isConnected,
            hasDataChannel,
            dataChannelState: dataChannel?.readyState,
          });

          // Clean up failed connections
          if (
            peerConnection.connectionState === "failed" ||
            peerConnection.iceConnectionState === "failed"
          ) {
            debugP2P(`Cleaning up failed connection for ${peerID}`);
            removePeer(peerID);
          }
        });

        updatePeersDisplay();
      }

      // Periodic connection health check
      setInterval(checkConnectionHealth, 10000); // Every 10 seconds

      // Manual retry connection function
      function retryConnections() {
        debugP2P(`Manual retry connections triggered`);

        // Request fresh peer list from signaling server
        if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
          signalingSocket.send(JSON.stringify({ type: "get-peers" }));
        }

        // Clean up failed connections
        checkConnectionHealth();
      }

      // Add retry button to UI (you can call this manually from console)
      window.retryP2PConnections = retryConnections;

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        isManualDisconnect = true;
        stopPingInterval();

        if (signalingSocket) {
          signalingSocket.close();
        }

        peers.forEach((pc) => pc.close());
      });

      // Handle page visibility changes to manage connections
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          console.log("Page hidden - maintaining connection");
        } else {
          console.log("Page visible - checking connection");

          // Check if connection is still alive when page becomes visible
          if (
            signalingSocket &&
            signalingSocket.readyState !== WebSocket.OPEN
          ) {
            console.log(
              "Connection lost while page was hidden, reconnecting..."
            );
            connectToSignalingServer();
          }
        }
      });
    </script>
  </body>
</html>
