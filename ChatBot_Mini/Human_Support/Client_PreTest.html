<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Client P2P Test - Vanced Support</title>
    <script src="websocket-webrtc.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f5f5;
      }
      .container {
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .status {
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        font-weight: bold;
      }
      .waiting {
        background: #fff3cd;
        color: #856404;
      }
      .connected {
        background: #d4edda;
        color: #155724;
      }
      .error {
        background: #f8d7da;
        color: #721c24;
      }
      .timeout {
        background: #f8d7da;
        color: #721c24;
      }

      .chat-area {
        border: 1px solid #ddd;
        height: 300px;
        overflow-y: auto;
        padding: 10px;
        margin: 10px 0;
        background: #fafafa;
      }
      .message {
        margin: 5px 0;
        padding: 8px;
        border-radius: 5px;
      }
      .user-msg {
        background: #007bff;
        color: white;
        text-align: right;
      }
      .admin-msg {
        background: #28a745;
        color: white;
        text-align: left;
      }

      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      input[type="text"] {
        width: 70%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>🧪 Client P2P Test - Vanced Support</h1>
      <div style="margin-bottom: 20px">
        <p>
          <strong>Base MachineID:</strong>
          <span id="baseMachineId">20250909S5690</span>
        </p>
        <div style="margin: 10px 0">
          <label for="machineIdSuffix"
            ><strong>Suffix (để test multiple clients):</strong></label
          >
          <input
            type="text"
            id="machineIdSuffix"
            placeholder="Nhập suffix..."
            style="width: 200px; margin-left: 10px"
            onchange="updateMachineId()"
            onkeyup="updateMachineId()"
          />
        </div>
        <p>
          <strong>Final MachineID:</strong>
          <span id="finalMachineId" style="color: #007bff; font-weight: bold"
            >20250909S5690</span
          >
        </p>
      </div>

      <div id="statusArea">
        <div class="status waiting" id="statusMsg">
          Sẵn sàng test P2P connection
        </div>
      </div>

      <div id="controlArea">
        <button id="requestSupportBtn" onclick="requestHumanSupport()">
          🆘 Yêu cầu gặp tư vấn viên
        </button>
        <button id="testSpreadsheetBtn" onclick="testSpreadsheetConnection()">
          📊 Test Spreadsheet Connection
        </button>
        <button id="testPeerJSBtn" onclick="testPeerJSConnection()">
          🔗 Test PeerJS Server
        </button>
        <button id="clearCacheBtn" onclick="clearBrowserCache()">
          🗑️ Clear Cache & Reload
        </button>
        <button id="testAllServersBtn" onclick="testAllPeerJSServers()">
          🔍 Test All Servers
        </button>
      </div>

      <div id="waitingArea" style="display: none">
        <h3>⏳ Đang chờ tư vấn viên...</h3>
        <p>Thời gian chờ: <span id="countdown">180</span> giây</p>
        <div id="peerInfo">
          <p><strong>PeerID:</strong> <span id="currentPeerID">-</span></p>
        </div>
      </div>

      <div id="chatArea" style="display: none">
        <h3>💬 Chat với tư vấn viên</h3>
        <div class="chat-area" id="chatMessages"></div>
        <div>
          <input
            type="text"
            id="messageInput"
            placeholder="Nhập tin nhắn..."
            onkeypress="if(event.key==='Enter') sendMessage()"
          />
          <button onclick="sendMessage()">Gửi</button>
          <button onclick="endChat()" style="background: #dc3545">
            Kết thúc
          </button>
        </div>
      </div>

      <div id="debugArea">
        <h4>🔧 Debug Info</h4>
        <div
          id="debugLog"
          style="
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
          "
        ></div>
      </div>
    </div>

    <script>
      // Configuration
      const BASE_MACHINE_ID = "20250909S5690";
      const SPREADSHEET_URL =
        "https://script.google.com/macros/s/AKfycbzZPxkICg1AHucIZ2AFQmnLLg_hjG8s9ouJUU9eSG1043AronwRwV45i5tMOQT5VuPDvw/exec"; // Cập nhật URL này

      // Global variables
      let peer = null;
      let connection = null;
      let countdownTimer = null;
      let isConnected = false;
      let currentMachineId = BASE_MACHINE_ID;

      // Update MachineID with suffix
      function updateMachineId() {
        const suffix = document.getElementById("machineIdSuffix").value.trim();
        currentMachineId = suffix
          ? `${BASE_MACHINE_ID}_${suffix}`
          : BASE_MACHINE_ID;

        document.getElementById("finalMachineId").textContent =
          currentMachineId;
        debugLog("MachineID updated", {
          baseMachineId: BASE_MACHINE_ID,
          suffix: suffix,
          finalMachineId: currentMachineId,
        });
      }

      // Debug logging
      function debugLog(message, data = null) {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${message}`;

        console.log(logMessage, data || "");

        const debugArea = document.getElementById("debugLog");
        const logEntry = document.createElement("div");
        logEntry.textContent =
          logMessage + (data ? ` | ${JSON.stringify(data)}` : "");
        debugArea.appendChild(logEntry);
        debugArea.scrollTop = debugArea.scrollHeight;
      }

      // Update status display
      function updateStatus(message, type = "waiting") {
        const statusMsg = document.getElementById("statusMsg");
        statusMsg.textContent = message;
        statusMsg.className = `status ${type}`;
        debugLog(`Status: ${message} (${type})`);
      }

      // Test Spreadsheet connection
      async function testSpreadsheetConnection() {
        updateStatus("Testing Spreadsheet connection...", "waiting");

        try {
          const url = new URL(SPREADSHEET_URL);
          url.searchParams.append("action", "initChat");
          url.searchParams.append("machineId", currentMachineId);
          url.searchParams.append("userIP", "test-ip");

          debugLog("Testing Spreadsheet connection", { url: url.toString() });

          const response = await fetch(url.toString());
          const data = await response.json();

          debugLog("Spreadsheet response", data);

          if (data.status === "existing_user" || data.status === "new_user") {
            updateStatus("✅ Spreadsheet connection successful!", "connected");
          } else {
            updateStatus("❌ Spreadsheet connection failed", "error");
          }
        } catch (error) {
          debugLog("Spreadsheet connection error", error.message);
          updateStatus("❌ Spreadsheet connection error", "error");
        }
      }

      // Request human support
      async function requestHumanSupport() {
        updateStatus("Khởi tạo WebSocket chat connection...", "waiting");

        // Generate custom PeerID and room
        const peerID = `client_${currentMachineId}_${Date.now()}`;
        const roomID = `support_${currentMachineId}`;

        debugLog("Generated client info for WebSocket chat", {
          machineId: currentMachineId,
          peerID: peerID,
          roomID: roomID,
        });

        try {
          // Save support request to Spreadsheet first
          await saveSupportRequestToSpreadsheet(peerID, roomID);

          // Connect to WebSocket chat server
          const wsUrl = `wss://vanced-chatbot.caocv-work.workers.dev/p2p/room/${roomID}?peerID=${peerID}&roomID=${roomID}&nickname=Client_${currentMachineId}`;

          debugLog("Connecting to WebSocket", { wsUrl });

          const chatSocket = new WebSocket(wsUrl);

          // Connection timeout
          const connectionTimeout = setTimeout(() => {
            debugLog("WebSocket connection timeout");
            updateStatus("⏰ Timeout kết nối WebSocket", "error");
            if (chatSocket) {
              chatSocket.close();
            }
          }, 30000);

          chatSocket.onopen = () => {
            clearTimeout(connectionTimeout);
            debugLog("WebSocket connected successfully");
            document.getElementById("currentPeerID").textContent = peerID;

            // Show waiting UI
            showWaitingUI();

            // Start countdown
            startCountdown();

            updateStatus("✅ Đang chờ tư vấn viên kết nối...", "waiting");
          };

          chatSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            handleChatMessage(message);
          };

          chatSocket.onclose = (event) => {
            clearTimeout(connectionTimeout);
            debugLog("WebSocket closed", {
              code: event.code,
              reason: event.reason,
            });
            if (!isConnected) {
              updateStatus("❌ Mất kết nối WebSocket", "error");
            }
          };

          chatSocket.onerror = (error) => {
            clearTimeout(connectionTimeout);
            debugLog("WebSocket error", error);
            updateStatus("❌ Lỗi kết nối WebSocket", "error");
          };

          // Store socket globally
          window.chatSocket = chatSocket;
        } catch (error) {
          debugLog("Request support error", error.message);
          updateStatus("❌ Lỗi khởi tạo WebSocket chat", "error");
        }
      }

      // Handle chat messages from WebSocket
      function handleChatMessage(message) {
        debugLog("Received WebSocket message", message);

        switch (message.type) {
          case "connected":
            debugLog("Connected to chat room", message);
            break;

          case "user-joined":
            if (message.peerID.startsWith("admin_")) {
              debugLog("Admin joined the chat!", message);
              isConnected = true;

              // Stop countdown
              if (countdownTimer) {
                clearInterval(countdownTimer);
              }

              // Show chat UI
              showChatUI();
              updateStatus("✅ Đã kết nối với tư vấn viên!", "connected");

              // Save connection info to spreadsheet
              saveConnectionToSpreadsheet(message.peerID, message.nickname);
            }
            break;

          case "user-left":
            if (message.peerID.startsWith("admin_")) {
              debugLog("Admin left the chat", message);
              updateStatus("❌ Tư vấn viên đã ngắt kết nối", "error");
              isConnected = false;
            }
            break;

          case "chat-message":
            if (message.fromPeerID.startsWith("admin_")) {
              debugLog("Received message from admin", message);
              displayMessage(message.text, "admin");
            }
            break;

          case "pong":
            debugLog("Received pong from server");
            break;

          default:
            debugLog("Unknown message type", message);
        }
      }

      // Save support request to Spreadsheet
      async function saveSupportRequestToSpreadsheet(peerID, roomID) {
        try {
          const supportData = {
            clientPeerID: peerID,
            roomID: roomID,
            adminPeerID: null,
            status: "waiting",
            adminNickname: null,
            timestamp: new Date().toISOString(),
            connectionStartTime: null,
            chatHistory: [],
          };

          const url = new URL(SPREADSHEET_URL);
          url.searchParams.append("action", "createSupportRequest");
          url.searchParams.append("machineId", currentMachineId);
          url.searchParams.append("supportData", JSON.stringify(supportData));

          debugLog("Saving support request to Spreadsheet", supportData);

          const response = await fetch(url.toString());
          const data = await response.json();

          debugLog("Spreadsheet save response", data);
        } catch (error) {
          debugLog("Save support request error", error.message);
        }
      }

      // Save connection info when admin joins
      async function saveConnectionToSpreadsheet(adminPeerID, adminNickname) {
        try {
          const connectionData = {
            adminPeerID: adminPeerID,
            adminNickname: adminNickname,
            status: "connected",
            connectionStartTime: new Date().toISOString(),
          };

          const url = new URL(SPREADSHEET_URL);
          url.searchParams.append("action", "updateSupportConnection");
          url.searchParams.append("machineId", currentMachineId);
          url.searchParams.append(
            "connectionData",
            JSON.stringify(connectionData)
          );

          debugLog("Saving connection info to Spreadsheet", connectionData);

          const response = await fetch(url.toString());
          const data = await response.json();

          debugLog("Connection save response", data);
        } catch (error) {
          debugLog("Save connection error", error.message);
        }
      }

      // Save chat message to Spreadsheet
      async function saveChatMessageToSpreadsheet(message) {
        try {
          const messageData = {
            from: message.from || "Admin",
            fromPeerID: message.fromPeerID,
            text: message.text,
            timestamp: message.timestamp,
            type: "admin",
          };

          const url = new URL(SPREADSHEET_URL);
          url.searchParams.append("action", "saveChatMessage");
          url.searchParams.append("machineId", currentMachineId);
          url.searchParams.append("messageData", JSON.stringify(messageData));

          debugLog("Saving chat message to Spreadsheet", messageData);

          const response = await fetch(url.toString());
          const data = await response.json();

          debugLog("Message save response", data);
        } catch (error) {
          debugLog("Save message error", error.message);
        }
      }

      // Show waiting UI
      function showWaitingUI() {
        document.getElementById("controlArea").style.display = "none";
        document.getElementById("waitingArea").style.display = "block";
      }

      // Show chat UI
      function showChatUI() {
        document.getElementById("waitingArea").style.display = "none";
        document.getElementById("chatArea").style.display = "block";
      }

      // Start countdown timer
      function startCountdown() {
        let timeLeft = 180; // 3 minutes
        const countdownElement = document.getElementById("countdown");

        countdownTimer = setInterval(() => {
          timeLeft--;
          countdownElement.textContent = timeLeft;

          if (timeLeft <= 0) {
            clearInterval(countdownTimer);
            handleTimeout();
          }
        }, 1000);
      }

      // Handle timeout
      function handleTimeout() {
        if (!isConnected) {
          updateStatus("⏰ Timeout - Không có tư vấn viên kết nối", "timeout");

          if (peer) {
            peer.destroy();
          }

          // Show fallback options
          alert(
            "Không có tư vấn viên trực tuyến. Vui lòng liên hệ:\nEmail: contact@vanced.agency\nPhone: 0123-456-789"
          );
        }
      }

      // Setup WebSocket ping to keep connection alive
      function startPingInterval() {
        if (
          window.chatSocket &&
          window.chatSocket.readyState === WebSocket.OPEN
        ) {
          setInterval(() => {
            if (
              window.chatSocket &&
              window.chatSocket.readyState === WebSocket.OPEN
            ) {
              window.chatSocket.send(JSON.stringify({ type: "ping" }));
              debugLog("Sent ping to server");
            }
          }, 30000); // Ping every 30 seconds
        }
      }

      // Send message via WebSocket
      function sendMessage() {
        const input = document.getElementById("messageInput");
        const message = input.value.trim();

        if (
          !message ||
          !window.chatSocket ||
          window.chatSocket.readyState !== WebSocket.OPEN
        )
          return;

        // Display message locally
        displayMessage(message, "user");

        // Create message object
        const messageData = {
          type: "chat-message",
          from: `Client_${currentMachineId}`,
          fromPeerID: document.getElementById("currentPeerID").textContent,
          text: message,
          timestamp: new Date().toISOString(),
          roomID: `support_${currentMachineId}`,
        };

        // Send via WebSocket
        window.chatSocket.send(JSON.stringify(messageData));

        debugLog("Sent message via WebSocket", messageData);
        input.value = "";
      }

      // Display message in chat
      function displayMessage(message, sender) {
        const chatMessages = document.getElementById("chatMessages");
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${
          sender === "user" ? "user-msg" : "admin-msg"
        }`;
        messageDiv.textContent = `${
          sender === "user" ? "Bạn" : "Tư vấn viên"
        }: ${message}`;

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // End chat
      function endChat() {
        if (
          window.chatSocket &&
          window.chatSocket.readyState === WebSocket.OPEN
        ) {
          // Send end chat message
          window.chatSocket.send(
            JSON.stringify({
              type: "chat-end",
              from: `Client_${currentMachineId}`,
              timestamp: new Date().toISOString(),
              roomID: `support_${currentMachineId}`,
            })
          );

          // Close WebSocket
          window.chatSocket.close();
        }

        // Save chat end to spreadsheet
        saveChatEndToSpreadsheet();

        updateStatus("✅ Đã kết thúc cuộc trò chuyện", "connected");

        // Reset UI
        document.getElementById("controlArea").style.display = "block";
        document.getElementById("waitingArea").style.display = "none";
        document.getElementById("chatArea").style.display = "none";

        // Clear chat messages
        document.getElementById("chatMessages").innerHTML = "";

        debugLog("Chat ended by client");
      }

      // Save chat end to Spreadsheet
      async function saveChatEndToSpreadsheet() {
        try {
          const endData = {
            status: "ended",
            endTime: new Date().toISOString(),
            endedBy: "client",
          };

          const url = new URL(SPREADSHEET_URL);
          url.searchParams.append("action", "endSupportChat");
          url.searchParams.append("machineId", currentMachineId);
          url.searchParams.append("endData", JSON.stringify(endData));

          debugLog("Saving chat end to Spreadsheet", endData);

          const response = await fetch(url.toString());
          const data = await response.json();

          debugLog("Chat end save response", data);
        } catch (error) {
          debugLog("Save chat end error", error.message);
        }
      }

      // List of alternative PeerJS servers
      const PEERJS_SERVERS = [
        {
          name: "Default PeerJS",
          config: { debug: 2 },
        },
        {
          name: "0.peerjs.com",
          config: {
            host: "0.peerjs.com",
            port: 443,
            path: "/",
            secure: true,
            debug: 2,
          },
        },
        {
          name: "PeerJS Heroku",
          config: {
            host: "peerjs-server.herokuapp.com",
            port: 443,
            path: "/",
            secure: true,
            debug: 2,
          },
        },
      ];

      let workingServerConfig = null;

      // Test PeerJS server connection
      async function testPeerJSConnection() {
        updateStatus("Testing PeerJS servers...", "waiting");

        for (let i = 0; i < PEERJS_SERVERS.length; i++) {
          const server = PEERJS_SERVERS[i];
          debugLog(`Testing server: ${server.name}`, server.config);

          const success = await testSingleServer(server);
          if (success) {
            workingServerConfig = server.config;
            updateStatus(`✅ Server hoạt động: ${server.name}`, "connected");
            return true;
          }
        }

        updateStatus("❌ Tất cả PeerJS servers đều không phản hồi", "error");
        return false;
      }

      // Test a single PeerJS server
      function testSingleServer(server) {
        return new Promise((resolve) => {
          try {
            const testPeerID = `test_${Date.now()}_${Math.random()
              .toString(36)
              .substr(2, 5)}`;
            debugLog(`Testing ${server.name} with ID`, testPeerID);

            const testPeer = new Peer(testPeerID, server.config);

            const testTimeout = setTimeout(() => {
              debugLog(`${server.name} timeout`);
              testPeer.destroy();
              resolve(false);
            }, 5000); // Reduced timeout

            testPeer.on("open", (id) => {
              clearTimeout(testTimeout);
              debugLog(`${server.name} test successful`, id);
              testPeer.destroy();
              resolve(true);
            });

            testPeer.on("error", (error) => {
              clearTimeout(testTimeout);
              debugLog(`${server.name} test error`, error);
              testPeer.destroy();
              resolve(false);
            });
          } catch (error) {
            debugLog(`${server.name} test exception`, error);
            resolve(false);
          }
        });
      }

      // Test all PeerJS servers manually
      async function testAllPeerJSServers() {
        updateStatus("Testing all servers manually...", "waiting");

        for (let i = 0; i < PEERJS_SERVERS.length; i++) {
          const server = PEERJS_SERVERS[i];
          updateStatus(`Testing ${server.name}...`, "waiting");

          const success = await testSingleServer(server);
          if (success) {
            workingServerConfig = server.config;
            updateStatus(`✅ ${server.name} hoạt động!`, "connected");
            debugLog("Manual test found working server", server);
            return;
          } else {
            updateStatus(`❌ ${server.name} không hoạt động`, "error");
            await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1s between tests
          }
        }

        updateStatus("❌ Không có server nào hoạt động", "error");
      }

      // Clear browser cache and reload
      function clearBrowserCache() {
        debugLog("Clearing cache and reloading");

        // Clear localStorage
        localStorage.clear();

        // Clear sessionStorage
        sessionStorage.clear();

        // Force reload without cache
        location.reload(true);
      }

      // Initialize on page load
      window.onload = function () {
        debugLog("Client PreTest initialized", {
          baseMachineId: BASE_MACHINE_ID,
          currentMachineId: currentMachineId,
          userAgent: navigator.userAgent,
          timestamp: new Date().toISOString(),
        });
        updateStatus("Sẵn sàng test P2P connection", "waiting");

        // Auto test PeerJS on load
        setTimeout(() => {
          debugLog("Auto-testing PeerJS server on load");
          testPeerJSConnection();
        }, 1000);
      };

      // Cleanup on page unload
      window.onbeforeunload = function () {
        if (peer) {
          peer.destroy();
        }
      };
    </script>
  </body>
</html>
